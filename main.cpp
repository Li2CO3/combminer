#include "mainwindow.h"
#include "calc.hpp"
#include <QApplication>
#include <iostream>
#include <QString>
int main(int argc, char *argv[])
{

    //当一个thread FINISH了，他会自动停止。开启新的，需要打开current_progress.txt修改文件，再开启程序以开启一个新的94^5。


    //当前进度:Li2CO3_600?s_???..??!!!!中，下一个字符是'3'以前的都完成，4~7即将完成。唯一一个20块全都是(会输出文件_00.txt)是!!!!67x|[R。
    //这将是22*94^5=1.614589e+011=1614亿。
    //408本身的几率倒数是56!/36!/20!/16/2=2.455042e13
    //出现24个块选20且有2赖子，是408的几率倒数是22*21*20*19/8/6/4/2=457.1875
    //24选20的出现几率倒数是2.455042*10^13/457.1875=5.36988e10。
    //前18块都是好块的几率是2*(18*17*22!/6!/56!*38!+18*2*2*22!/5!/56!*37!+2*1*22!/4!/56!*36!)=3719/5101386767295= 7.290174553794899e-10
    //倒数为1.371709267893249e+9

    //94^5=7339040224=7.3e9


    //现在我没有内置判断是不是408的功能。目前我只见过一个24选20.
//Li2CO3_600?s_
//?????????????????????????????????????????????????????????????????????
//?????????????????????????????????????????????????????????????????????
//?????????????????????????????????????????????????????????????????????
//?????????????????????????????????????????????????????????????????????
//?????????????????????????????????????????????????????????????????????
//?????????????????????????????????????????????????????????????????????
//?????????????????????????????????????????????????????????????????????
//?????????????????????????????????????????????????????????????????????
//????????????????????????????????????????????????!!!!67x|[R


    //可以找一些例子来验证。
    //我现在最熟悉的是#!#L^D@
    //

//    std::ios::init();
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
    MainWindow *pw=&w;
    std::string str[NTHREAD];

    FILE *f =fopen("current_progress.txt","r");//从current_progress读取
    FILE *fcopy = fopen("starting_progress.txt","w");
    for(int i=0;i<NTHREAD;i++)
    {char ch[25];
        char thestr[11]="XXXXXXXXXX";
        fscanf(f,"%s",ch);
        fprintf(fcopy,"%s\n",ch);
        for(int id=0;id<NTHREAD;id++)
        {
            bool is_last_backslash=false;
            int targetpos=0;
        for(int readingpos=1;targetpos!=10;readingpos++)
            {
                if(ch[readingpos]!='\\' || is_last_backslash)
                    {thestr[targetpos]=ch[readingpos];++targetpos;is_last_backslash=false;}
                else
                    {is_last_backslash=true;continue;}

            }


        }
        str[i]=string(thestr);
    }
    fclose(f);
    fclose(fcopy);

    




//从current_progress.txt复制







     //"!!!#!#L^!!",//测试，因为L^D@是要输出的


    for(int i=0; i<NTHREAD;i++)
    {
        w.label1[i]->setText(str[i].c_str());
            w.label2[i]->setText("0");

            w.c[i]=new Calc(str[i]);
        w.c[i]->start();
            w.connect(w.c[i],&Calc::New_Discover,&w,[=](int t)
                  {int s=1<<20; for(int i=0;i<t;i++)s>>=4; pw->label2[i]->setText(QString::number(pw->label2[i]->text().toInt(nullptr,16)+s ,16));});
        w.connect(w.c[i],&Calc::Update_Progress,&w,[=](QString str){pw->label1[i]->setText(str);pw->progress[i]=str; });

    }
    return a.exec();

}
